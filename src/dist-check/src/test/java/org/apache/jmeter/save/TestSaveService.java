/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to you under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.jmeter.save;


import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.fail;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.regex.Pattern;

import org.apache.jmeter.junit.JMeterTestCase;
import org.apache.jmeter.util.JMeterUtils;
import org.apache.jorphan.collections.HashTree;
import org.apache.xml.security.Init;
import org.apache.xml.security.c14n.Canonicalizer;
import org.eclipse.jgit.diff.DiffFormatter;
import org.eclipse.jgit.diff.EditList;
import org.eclipse.jgit.diff.HistogramDiff;
import org.eclipse.jgit.diff.RawText;
import org.eclipse.jgit.diff.RawTextComparator;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.FieldSource;

public class TestSaveService extends JMeterTestCase {

    // testLoadAndSave test files
    private static final String[] FILES = new String[] {
        "AssertionTestPlan.jmx",
        "AuthManagerTestPlan.jmx",
        "HeaderManagerTestPlan.jmx",
        "InterleaveTestPlan2.jmx",
        "InterleaveTestPlan.jmx",
        "LoopTestPlan.jmx",
        "Modification Manager.jmx",
        "OnceOnlyTestPlan.jmx",
        "proxy.jmx",
        "ProxyServerTestPlan.jmx",
        "SimpleTestPlan.jmx",
        "GuiTest.jmx",
        "GuiTest231.jmx",
        // autogenerated test files
        "GenTest27.jmx", // 2.7
        "GenTest210.jmx", // 2.10
        "GenTest2_13.jmx", // 2.13
        "GenTest3_0.jmx", // 3.0
        };

    // Test files for testLoadAndSave; output will generally be different in size but same number of lines
    private static final String[] FILES_LINES = new String[] {
        "GuiTest231_original.jmx",
        "GenTest25.jmx", // GraphAccumVisualizer obsolete, BSFSamplerGui now a TestBean
        "GenTest251.jmx", // GraphAccumVisualizer obsolete, BSFSamplerGui now a TestBean
        "GenTest26.jmx", // GraphAccumVisualizer now obsolete
        "GenTest27_original.jmx", // CTT changed to use intProp for mode
    };

    // Test files for testLoad; output will generally be different in size and line count
    private static final String[] FILES_LOAD_ONLY = new String[] {
        "GuiTest_original.jmx",
        "GenTest22.jmx",
        "GenTest231.jmx",
        "GenTest24.jmx",
        };

    private static final boolean saveOut = JMeterUtils.getPropDefault("testsaveservice.saveout", false);

    @BeforeAll
    static void initXmlSecurity() {
        Init.init();
    }

    @Test
    public void testPROPVERSION() {
        assertEquals(
                SaveService.PROPVERSION,
                SaveService.getPropertyVersion(),
                "Property Version mismatch, ensure you update SaveService#PROPVERSION field with _version property value from saveservice.properties"
        );
    }

    @ParameterizedTest
    @FieldSource({"FILES", "FILES_LINES"})
    void loadAndSave(String fileName) throws Exception {
        File testFile = findTestFile("testfiles/" + fileName);
        ByteArrayOutputStream out = new ByteArrayOutputStream(Math.toIntExact(testFile.length()));
        try (out) {
            HashTree tree = SaveService.loadTree(testFile);
            SaveService.saveTree(tree, out);
        }
        byte[] resavedXml = out.toByteArray();
        // Make sure all the data is flushed out

        // Compare XML content using normalized form for better diff output
        Path testFilePath = testFile.toPath();
        Path expectedOutput = testFilePath.resolveSibling(testFilePath.getFileName().toString().replace(".jmx", ".expected.jmx"));
        Path expectedFilePath = Files.exists(expectedOutput) ? expectedOutput : testFilePath;

        String expectedXml = normalizeXml(
                Files.readAllBytes(
                        expectedFilePath
                )
        );
        String actualXml = normalizeXml(resavedXml);

        if (saveOut) {
            if (!expectedXml.equals(actualXml)) {
                Files.write(expectedOutput, resavedXml);
            }
            return;
        }
        assertEquals(
                expectedXml,
                actualXml,
                () -> {
                    String diff = computeHistogramDiff(expectedXml, actualXml);
                    StringBuilder message = new StringBuilder();
                    message.append("JMX file should be the same after load and save. ");
                    message.append("Comparing with ").append(expectedFilePath).append(". ");
                    message.append(" (diff is ").append(diff.length()).append(" chars, ")
                            .append(Math.round(diff.length() * 100.0 / expectedXml.length())).append("% of original)");

                    // Omit diff it is too large
                    if (diff.length() < expectedXml.length() * 0.8) {
                        message.append("\nDiff:\n").append(diff);
                    }
                    return message.toString();
                }
        );
    }

    @ParameterizedTest
    @FieldSource("FILES_LOAD_ONLY")
    public void testLoad(String fileName) throws Exception {
        File file = findTestFile("testfiles/" + fileName);
        try {
            HashTree tree = SaveService.loadTree(file);
            assertNotNull(tree);
        } catch (IllegalArgumentException ex) {
            ex.addSuppressed(new Throwable("fileName=" + file.getAbsolutePath()));
            throw ex;
        }
    }

    @Test
    public void testClasses(){
        List<String> missingClasses = SaveService.checkClasses();
        if (!missingClasses.isEmpty()) {
            fail("One or more classes not found:"+missingClasses);
        }
    }

    /**
     * Pattern to match the jmeterTestPlan root element with all its attributes.
     * These attributes (jmeter version, properties version) change between JMeter versions
     * and should be ignored when comparing XML content.
     */
    private static final Pattern JMETER_TEST_PLAN_PATTERN = Pattern.compile(
            "<jmeterTestPlan[^>]*>"
    );

    /**
     * Normalizes XML for comparison using W3C Canonical XML (C14N).
     * This sorts attributes alphabetically and normalizes whitespace.
     * Also normalizes the jmeterTestPlan root element to ignore version differences.
     */
    private static String normalizeXml(byte[] xmlBytes) throws Exception {
        Canonicalizer c14n = Canonicalizer.getInstance(Canonicalizer.ALGO_ID_C14N_OMIT_COMMENTS);
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        c14n.canonicalize(xmlBytes, out, true);

        // Normalize the jmeterTestPlan element to ignore version-specific attributes
        String xml = out.toString(StandardCharsets.UTF_8);
        xml = JMETER_TEST_PLAN_PATTERN.matcher(xml).replaceFirst("<jmeterTestPlan>");

        return xml;
    }


    private static String computeHistogramDiff(String expected, String actual) {
        return computeHistogramDiff(
                expected.getBytes(StandardCharsets.UTF_8),
                actual.getBytes(StandardCharsets.UTF_8)
        );
    }

    /**
     * Computes a histogram diff between expected and actual text, similar to git diff.
     */
    private static String computeHistogramDiff(byte[] expected, byte[] actual) {
        try {
            RawText expectedText = new RawText(expected);
            RawText actualText = new RawText(actual);

            EditList edits = new HistogramDiff().diff(RawTextComparator.DEFAULT, expectedText, actualText);

            ByteArrayOutputStream diffOutput = new ByteArrayOutputStream();
            try (DiffFormatter formatter = new DiffFormatter(diffOutput)) {
                formatter.format(edits, expectedText, actualText);
            }
            return diffOutput.toString(StandardCharsets.UTF_8);
        } catch (IOException e) {
            return "Failed to compute diff: " + e.getMessage();
        }
    }
}
